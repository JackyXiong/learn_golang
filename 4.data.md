#数据

## 数组
* 长度是常量，是数组类型的一部分。[3]int 和 [4]int 是两个不同的类型
* 需要分清楚指针数组 `[n]*T` 和数组指针 `*[n]T`
* 支持多维数组 
* 数组是值类型，赋值或传参会复制数组，不是复制指针
* 创建数组的方式
```
a := [3]int{1}
a := [...]{1, 2, 3}
a := [5]int{2: 10}
```

## slice
```
struct Slice
{
    byte* array;  // 实际数据
    unitgo len;   //
    unitgo cap;   //
}
```
* 实际上是数组的片段，通过内部指针和其他属性实现，长度可变。而数组是定长的。
* 是引用类型，但是其自身是一个结构体。有2种容量, cap 是最大容量，len是初始长度。
* 读写slice，实际上都是操作的底层数组。
* 创建slice的方式
  * 直接创建，自动分配底层数组。
  * 使用索引号从数组创建
  * make函数创建
  ```go
  s := []int{0, 1, 2, 3, 9:10} // 自动设置len=cap=9，未显示指定值的索引位置，自动分配当前元素类型的默认值
  a = [...]int{1,2,3,4,5}
  s = a[1:2:3] // array[low:high:max] // 省略low默认为0，省略high和max默认为到数组最后一个元素截止
  s = make([]int, len, cap)
  ```
* slice 还可以reslice，reslice 出来的对象还是指向底层数组，修改新对象元素的值，也会修改数组的值
* func append(s []T, x ...T) []T: 向slice尾部添加值，也会影响原数组。若超过了cap的限制，则会重新分配新的底层数组。
重新分配通常是以现有slice的2倍容量分配。 
* func copy(dst, src []T) []T: 在两个slice之间复制数据，复制的长度取决于len小的那个slice。dst和src可以是指向同一个数组的slice
参考test2

## Map
* 哈希表，引用类型。其键是支持 == != 运算符类型，如 number string pointer array struct interface 。值可以是任意类型
* 创建map的方式
  * 直接创建: `m := map[T1]T2 {}` T1是键2类型，T2是值类型
  * make函数创建: `m := make(map[T1]T2, length)` 设置make的数量参数，可在创建时申请内存，减小性能消耗
  ```
	m1 := map[string]int{
		"a": 1, "b": 2,
	}
	m2 := make(map[string]int, 10)
	m2["a"] = 1
	fmt.Println(m1, m2)
  ```
* 取值m["k"]，存在k返回对应的值和true，不存在返回0和false。当m["k"]==0时，判断k存在用第二个返回值。
新增或修改: m["k"] = 1，删除: delete(m, "k")。k不存在也不会报错。获取数量:len(m)
* 迭代：随机顺序返回，具体实现和go版本有关。可仅返回k，可同时返回k,v
* 由k取出的v是复制品，当v是struct时，对v成员的修改无法修改map的元素。只能替换map的元素，或者使用指针
参考test3

## Strcut 
* 值类型，赋值和传参会复制全部内容，支持指向其自身的指针作为其成员。
* 初始化时，若不指明成员名，则需要包含全部字段，否则会报错。
* strcut可用作map的键
* 匿名字段是一种语法糖，访问匿名字段，编译器由内向外逐级查找所有层次的匿名字段，直到找到该字段和出错。
参考 test4


